

/*

  No storing the binding with teh genome allowed.

  Genome has the binding.   
  Genome creates an archetypal genotype. 
    Genotype is just some dictionaries, with perhaps the orig values. (perhaps not)
    Genotype is initialized from a binding. 
  Genome creates a specimen from a Genotype

*/



require DFGWrapper;

// alias UInt8 DFGPortType;
// const DFGPortType DFGPortType_In = 0;
// const DFGPortType DFGPortType_IO = 1;
// const DFGPortType DFGPortType_Out = 2;
// const DFGPortType DFGPortType_Invalid = 3;

// alias UInt8 DFGNodeType;
// const DFGNodeType DFGNodeType_Function = 0;
// const DFGNodeType DFGNodeType_Graph = 1;
// const DFGNodeType DFGNodeType_Inst = 2;
// const DFGNodeType DFGNodeType_Invalid = 3;




object SimpLPopulation {
  String path;
  DFGBindingManager bindingManager;
  DFGBindingWrapper binding;

  SimpLGenotype archetype;
  SimpLGenotype genepool[];
  SimpLSpecimen population[];

  SimpLFitness fitness;

  Scalar breederRate;
  Scalar mutationRate;
  Scalar mutationAmount;
  Scalar insertionRate;
  Scalar deletionRate;
  Scalar crossoverRate;

  Size seed;
  Size randIt;
};


function SimpLPopulation() {
  this.bindingManager = DFGBindingManager();
}

/// \dfgPresetDefault mutationRate 0.2
/// \dfgPresetDefault mutationAmount 0.01;
/// \dfgPresetDefault insertionRate 0.01;
/// \dfgPresetDefault deletionRate 0.01;
/// \dfgPresetDefault crossoverRate 0.01;
function SimpLPopulation.setup!(FilePath dfgPath, SimpLFitness fitness, Scalar breederRate,
                                Scalar mutationRate, Scalar mutationAmount, 
                                Scalar insertionRate, Scalar deletionRate, Scalar crossoverRate
                                ) {
  if (this.path != dfgPath.string()) {
    this.path = dfgPath.string();
    this.bindingManager.registerFile("SimpLSeedBinding", this.path);
    this.binding = this.bindingManager.getBinding("SimpLSeedBinding");
    this.archetype = SimpLGenotype(this.binding);
  }

  this.fitness = fitness;

  this.breederRate = breederRate;

  this.mutationRate = mutationRate;
  this.mutationAmount = mutationAmount;
  this.insertionRate = insertionRate;
  this.deletionRate = deletionRate;
  this.crossoverRate = crossoverRate;

  this.seed = 12345;
}

function SimpLPopulation.iterate!(Boolean reset, Size populationSize, 
                                  Size maxIterations, Size desiredStringLength, 
                                  out SimpLSpecimen population[]) {
  if (reset)
    this.genepool.resize(0);
  this.breedNextGeneration(populationSize);
  this.growPopulation(maxIterations, desiredStringLength);
  this.evaluatePopulation();
  population = this.population;
}

private inline Size SimpLPopulation.randSelect!(Size start, Size end) {
  return Size(mathRandomScalar(this.seed, this.randIt++, start, Scalar(end) - 0.001));
}

private function SimpLPopulation.breedNextGeneration!(Size populationSize) {
  SimpLGenotype lastGen[];
  Boolean reset = !Boolean(this.genepool);
  if (reset)
    lastGen.push(this.archetype.clone());
  else
    lastGen = this.genepool.clone();

  this.genepool.resize(populationSize);


  Microtimer timer("breeding");
  for (Size i=0; i<populationSize; i++) {
    Size mom = this.randSelect(0, lastGen.size());
    Size dad = this.randSelect(0, lastGen.size());
    this.genepool[i] = lastGen[mom].mix(lastGen[dad], this.seed, this.randIt);
    if (reset)
      continue;
 
    this.genepool[i].mutate(this.mutationRate, this.mutationAmount, this.seed, this.randIt);
    this.genepool[i].mutate(this.mutationRate, this.mutationAmount, this.seed, this.randIt);
    this.genepool[i].stringMutate(this.insertionRate, this.deletionRate, this.seed, this.randIt);
    this.genepool[i].crossover(this.seed, this.crossoverRate, this.randIt);
  }
  timer.report();
}

private function SimpLPopulation.growPopulation!(Size maxIterations, Size desiredStringLength) {
  this.population.resize(0);
  for (Size i =0; i<this.genepool.size(); i++) {
    SimpLSpecimen specimen = this.createSpecimen(this.genepool[i], maxIterations, desiredStringLength);
    this.population.push(specimen);
  }
}
private function SimpLPopulation.evaluatePopulation!() {
  SimpLSpecimen specimens[];
  Scalar probability[] = this.fitness.apply(this.population);
  if (probability.size() == 0)
    return;

  Scalar cumulative[];
  cumulative.resize(probability.size());
  for (Size i=0; i<probability.size(); i++)
    cumulative[i] = ((i>0) ? cumulative[i-1] : 0) + probability[i];
  Scalar total = cumulative[cumulative.size() - 1];

  Size numBreeders = Math_max(this.population.size() * this.breederRate, 1);
  SimpLGenotype selections[];
  for (Size s=0; s<numBreeders; s++) {
    Scalar selector = mathRandomScalar(this.seed, this.randIt++, 0.0, total);
    for (Size i=0; i<cumulative.size(); i++) {
      if (cumulative[i] > selector) {
        report("selecting "+i);
        selections.push(this.genepool[i].clone());
        break;
      }
    }
  }
  report(cumulative);
  this.genepool = selections;
}





/// \dfgPresetDefault maxIterations 50;
/// \dfgPresetDefault desiredStringLength 100000;
function SimpLSpecimen SimpLPopulation.createSpecimen!(Size maxIterations, Size desiredStringLength) {
  return this.createSpecimen(this.archetype, maxIterations, desiredStringLength);
}


private function SimpLSpecimen SimpLPopulation.createSpecimen!(SimpLGenotype genotype, Size maxIterations, Size desiredStringLength) {
  /*
    Increase iterations until the string is as long as we want it
    Then enable "create geo", and get a specimen.  
  */
  String errors;
  for (Size i=0; i<maxIterations; i++ ) {
    this.binding.setArgValue("createGeo", RTVal(false));
    this.binding.setArgValue("iterations", RTVal(Scalar(i)));
    this.binding.execute(errors);
    if (errors) {
      report("Errors executing bindings:");
      report(errors);
      setError("Errors executing bindings.");
    }
    String evolvedString = String(this.binding.getArgValue("evolved"));
    if (evolvedString.length() >= desiredStringLength)
      break;
  }
  this.binding.setArgValue("createGeo", RTVal(true));

  for (key, value in genotype.stringPortValues)
    this.binding.setArgValue(key, RTVal(value));
  for (key, value in genotype.scalarPortValues)
    this.binding.setArgValue(key, RTVal(value));
  for (key, value in genotype.integerPortValues)
    this.binding.setArgValue(key, RTVal(value));

  this.binding.execute(errors);
  if (errors) {
    report("Errors executing bindings:");
    report(errors);
    setError("Errors executing bindings.");
  }

  RTVal linesRT = this.binding.getArgValue("lines");
  Xfo leaves[](this.binding.getArgValue("leaves"));
  String evolved(this.binding.getArgValue("evolved"));

  Lines lines = null;
  if (linesRT.type() == Lines)
    lines = Lines(linesRT);
  else
    lines = Lines();

  return SimpLSpecimen(lines, leaves, evolved);;
}

