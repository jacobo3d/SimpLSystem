

/*

  No storing the binding with teh genome allowed.

  Genome has the binding.   
  Genome creates an archetypal genotype. 
    Genotype is just some dictionaries, with perhaps the orig values. (perhaps not)
    Genotype is initialized from a binding. 
  Genome creates a specimen from a Genotype

*/



require DFGWrapper;

// alias UInt8 DFGPortType;
// const DFGPortType DFGPortType_In = 0;
// const DFGPortType DFGPortType_IO = 1;
// const DFGPortType DFGPortType_Out = 2;
// const DFGPortType DFGPortType_Invalid = 3;

// alias UInt8 DFGNodeType;
// const DFGNodeType DFGNodeType_Function = 0;
// const DFGNodeType DFGNodeType_Graph = 1;
// const DFGNodeType DFGNodeType_Inst = 2;
// const DFGNodeType DFGNodeType_Invalid = 3;




object SimpLPopulation {
  String path;
  DFGBindingManager bindingManager;
  DFGBindingWrapper binding;

  SimpLGenotype archetype;
  SimpLGenotype genepool[];
  SimpLSpecimen population[];

  SimpLFitness fitness;

  Scalar breederRate;
  Scalar mutationRate;
  Scalar mutationAmount;
  Scalar crossoverRate;

  Size randIt;
};


function SimpLPopulation() {
  this.bindingManager = DFGBindingManager();
}

function SimpLPopulation.setup!(FilePath dfgPath, SimpLFitness fitness, Scalar breederRate,
                                Scalar mutationRate, Scalar mutationAmount, Scalar crossoverRate) {
  if (this.path != dfgPath.string()) {
    this.path = dfgPath.string();
    this.bindingManager.registerFile("SimpLSeedBinding", this.path);
    this.binding = this.bindingManager.getBinding("SimpLSeedBinding");
    this.archetype = SimpLGenotype(this.binding);
  }

  this.fitness = fitness;

  this.mutationRate = mutationRate;
  this.mutationAmount = mutationAmount;
  this.crossoverRate = crossoverRate;

}

function SimpLPopulation.iterate!(Boolean reset, Size populationSize, 
                                  Size maxIterations, Size desiredStringLength, 
                                  out SimpLSpecimen population[]) {
  if (reset)
    this.genepool.resize(0);

  this.breedNextGeneration(populationSize);
  this.growPopulation(maxIterations, desiredStringLength);
  this.evaluatePopulation();
  population = this.population;
}


private function SimpLPopulation.breedNextGeneration!(Size populationSize) {
  SimpLGenotype lastGen[];
  if (this.genepool) {
    lastGen = this.genepool.clone();
  }
  else {
    report("Resetting.");
    lastGen.push(this.archetype);
  }
  this.genepool.resize(populationSize);
  Size seed = 12345;
  for (Size i=0; i<populationSize; i++) {
    this.genepool[i] = lastGen[0].mix(lastGen[0], seed, this.randIt);
    this.genepool[i].mutate(this.mutationRate, this.mutationAmount, seed, this.randIt);
    this.genepool[i].stringMutate(this.insertionRate, this.deletionRate, seed, this.randIt);
    this.genepool[i].crossover(seed, this.randIt);
  }
}

private function SimpLPopulation.growPopulation!(Size maxIterations, Size desiredStringLength) {
  this.population.resize(0);
  for (Size i =0; i<this.genepool.size(); i++) {
    SimpLSpecimen specimen = this.createSpecimen(this.genepool[i], maxIterations, desiredStringLength);
    this.population.push(specimen);
  }
}
private function SimpLPopulation.evaluatePopulation!() {
  SimpLSpecimen specimens[];

  Scalar probability[] = this.fitness.apply(this.population);


  // to do: select X survivors, remove the rest.
}





/// \dfgPresetDefault maxIterations 50;
/// \dfgPresetDefault desiredStringLength 100000;
function SimpLSpecimen SimpLPopulation.createSpecimen!(Size maxIterations, Size desiredStringLength) {
  return this.createSpecimen(this.archetype, maxIterations, desiredStringLength);
}


private function SimpLSpecimen SimpLPopulation.createSpecimen!(SimpLGenotype genotype, Size maxIterations, Size desiredStringLength) {
  /*
    Increase iterations until the string is as long as we want it
    Then enable "create geo", and get a specimen.  
  */
  String errors;
  for (Size i=0; i<maxIterations; i++ ) {
    this.binding.setArgValue("createGeo", RTVal(false));
    this.binding.setArgValue("iterations", RTVal(Scalar(i)));
    this.binding.execute(errors);
    if (errors) {
      report("Errors executing bindings:");
      report(errors);
      setError("Errors executing bindings.");
    }
    String evolvedString = String(this.binding.getArgValue("evolved"));
    if (evolvedString.length() >= desiredStringLength)
      break;
  }
  this.binding.setArgValue("createGeo", RTVal(true));

  for (key, value in genotype.stringPortValues)
    this.binding.setArgValue(key, RTVal(value));
  for (key, value in genotype.scalarPortValues)
    this.binding.setArgValue(key, RTVal(value));
  for (key, value in genotype.integerPortValues)
    this.binding.setArgValue(key, RTVal(value));

  this.binding.execute(errors);
  if (errors) {
    report("Errors executing bindings:");
    report(errors);
    setError("Errors executing bindings.");
  }

  RTVal linesRT = this.binding.getArgValue("lines");
  Xfo leaves[](this.binding.getArgValue("leaves"));
  String evolved(this.binding.getArgValue("evolved"));

  Lines lines = null;
  if (linesRT.type() == Lines)
    lines = Lines(linesRT);
  else
    lines = Lines();

  return SimpLSpecimen(lines, leaves, evolved);;
}

