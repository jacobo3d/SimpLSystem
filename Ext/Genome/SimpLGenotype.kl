

/*

  No storing the binding with teh genome allowed.

  Genome has the binding.   
  Genome creates an archetypal genotype. 
    Genotype is just some dictionaries, with perhaps the orig values. (perhaps not)
    Genotype is initialized from a binding. 
  Genome creates a specimen from a Genotype

*/



require DFGWrapper;

// alias UInt8 DFGPortType;
// const DFGPortType DFGPortType_In = 0;
// const DFGPortType DFGPortType_IO = 1;
// const DFGPortType DFGPortType_Out = 2;
// const DFGPortType DFGPortType_Invalid = 3;

// alias UInt8 DFGNodeType;
// const DFGNodeType DFGNodeType_Function = 0;
// const DFGNodeType DFGNodeType_Graph = 1;
// const DFGNodeType DFGNodeType_Inst = 2;
// const DFGNodeType DFGNodeType_Invalid = 3;


struct SimpLGenotype {
  String usedSymbols;
  String stringPortValues[String];
  Scalar scalarPortValues[String];
  Integer integerPortValues[String];
};



function SimpLGenotype(DFGBindingWrapper binding) {
  DFGPortType reservedPorts[String];
  reservedPorts["iterations"] = DFGPortType_In;
  reservedPorts["createGeo"] = DFGPortType_In;
  reservedPorts["lines"] = DFGPortType_Out;
  reservedPorts["leaves"] = DFGPortType_Out;
  reservedPorts["evolved"] = DFGPortType_Out;

  for (Size i=0; i<binding.getArgCount(); i++) {
    String name = binding.getArgName(i);

    DFGPortType portType = binding.getArgPortType(name);
    if (reservedPorts.has(name)) {
      // reserved ports do not get added to the port values. 
      if (portType != reservedPorts[name])
        setError("Reserved port "+name+" is wrong type (in, out, etc).");
      reservedPorts.delete(name);
      continue;
    }

    if (portType == DFGPortType_In) {
      String dataType = binding.getArgDataType(name);
      RTVal rtval = binding.getArgValue(name);
      if (dataType == "String")
        this.stringPortValues[name] = String(rtval).replace('"', '');
      if (dataType == "Float32")
        this.scalarPortValues[name] = Float32(rtval);
      if (dataType == "SInt32")
        this.integerPortValues[name] = SInt32(rtval);
    }
  }

  if (reservedPorts) {
    report("Graph is missing some ports: "+reservedPorts);
    setError("Graph is missing some ports: "+reservedPorts);
  }

  Boolean usedLetters[String];
  for (key, value in this.stringPortValues) {
    for (Size i=0; i<value.length(); i++)
      usedLetters[value[i]] = true;
    for (key in usedLetters)
      this.usedSymbols += key;
  }
}


function SimpLGenotype SimpLGenotype.mix(SimpLGenotype other, Size seed, io Size randID) {
  // mix up self with another to make a whole new thing
  SimpLGenotype offspring();
  offspring.usedSymbols = this.usedSymbols;
  for (key, value in this.scalarPortValues) {
    Scalar rand = mathRandomScalar(seed, randID++, -1.0, 1.0);
    offspring.scalarPortValues[key] = rand > 0.0 ? this.scalarPortValues[key] : other.scalarPortValues[key];
  }
  for (key, value in this.integerPortValues) {
    Scalar rand = mathRandomScalar(seed, randID++, -1.0, 1.0);
    offspring.integerPortValues[key] = rand > 0.0 ? this.integerPortValues[key] : other.integerPortValues[key];
  }
  for (key, value in this.stringPortValues) {
    Scalar rand = mathRandomScalar(seed, randID++, -1.0, 1.0);
    offspring.stringPortValues[key] = rand > 0.0 ? this.stringPortValues[key].clone() : other.stringPortValues[key].clone();
  }
  return offspring;
}

function SimpLGenotype.mutate!(Scalar mutationRate, Scalar mutationAmount, Size seed, io Size randID) {
  for (key, value in this.scalarPortValues) {
    Scalar rand = mathRandomScalar(seed, randID++, 0.0, 1.0);
    if (rand > mutationRate)
      continue;
    Scalar mutRand = mathRandomScalar(seed, randID++, -1.0, 1.0);
    Scalar mutation = 1.0 + mutRand * mutationAmount;
    if (value == 0.0)
      this.scalarPortValues[key] = mutRand * 0.01;
    else
      this.scalarPortValues[key] *= mutation;
  }
  for (key, value in this.integerPortValues) {
    Scalar rand = mathRandomScalar(seed, randID++, 0.0, 1.0);
    Scalar mutRand = mathRandomScalar(seed, randID++, -1.0, 1.0);
    if (rand > mutationRate)
      continue;
    if (mutRand > 0.0)
      this.integerPortValues[key] += 1;
    else
      this.integerPortValues[key] += 1;
  }
}

private inline Size SimpLGenotype.randSelect(Size start, Size end, Size seed, io Size randID) {
  return Size(mathRandomScalar(seed, randID++, start, Scalar(end) - 0.001));
}

function SimpLGenotype.stringMutate!(Scalar insertionRate, Scalar deletionRate, Size seed, io Size randID) {
  for (key, value in this.stringPortValues) {
    // insert or remove a character
    Scalar insertRand = mathRandomScalar(seed, randID++, 0.0, 1.0);
    Scalar deleteRand = mathRandomScalar(seed, randID++, 0.0, 1.0);
    if (insertRand < insertionRate) {
      // insertion:
      Size len = value.length();
      Size insertIndex = this.randSelect(0, len, seed, randID);
      String symbol = this.usedSymbols[this.randSelect(0, this.usedSymbols.length(), seed, randID)];
      if (len == 0)
        insertIndex = 0;

      String alsoInsertSymbol;
      Size alsoInsertIndex;
      if (symbol == "[") {
        alsoInsertSymbol = "]";
        alsoInsertIndex = this.randSelect(insertIndex, len, seed, randID);
        if (alsoInsertIndex <= insertIndex || alsoInsertIndex >= len)
          continue;
      }
      if (symbol == "]") {
        alsoInsertSymbol = "[";
        alsoInsertIndex = this.randSelect(0, insertIndex, seed, randID);
        if (alsoInsertIndex >= insertIndex || alsoInsertIndex >= len)
          continue;
      }

      String newString;
      for (Size i = 0; i < len; i++) {
        if (i == insertIndex)
          newString += symbol;
        if (i == alsoInsertIndex)
          newString += alsoInsertSymbol;
        newString += value[i];
      }

      this.stringPortValues[key] = newString;
      value = newString;
    }

    if (deleteRand < deletionRate) {
      // insertion:
      Size len = value.length();
      if (len == 0)
        continue;
      Size deleteIndex = this.randSelect(0, len, seed, randID);
      String deleteSymbol = value[deleteIndex];

      Size alsoDelete = -1;
      if (deleteSymbol == "[") {
        Integer location = value.find("]", deleteIndex);
        if (location == -1)
          continue;
        else
          alsoDelete = location;
      }
      if (deleteSymbol == "]") {
        Integer location = value.find("[");
        if (location == -1 || location <= deleteIndex)
          continue;
        else
          alsoDelete = location;
      }
      String newString();
      for (Size i = 0; i < len; i++) {
        if (i == deleteIndex)
          continue;
        if (i == alsoDelete)
          continue;
        newString += value[i];
      }

      this.stringPortValues[key] = newString;
      value = newString;
    }
  }
}

function SimpLGenotype.crossover!(Size seed, Scalar crossoverRate, io Size randID) {
  if (this.stringPortValues.size() < 2)
    return;
  String values[];
  for (key, value in this.stringPortValues)
    values.push(value);
  for (Size i =0; i<values.size(); i++) {
    String string = values[i];

    Scalar rand = mathRandomScalar(seed, randID++, 0.0, 1.0);
    if (rand > crossoverRate)
      continue;
    Size otherIndex = this.randSelect(0, values.size(), seed, randID);
    if (otherIndex == i) {
      continue;
    }
    String otherString = values[otherIndex];

    Size cut = this.randSelect(0, string.length(), seed, randID);
    Size otherCut = this.randSelect(0, otherString.length(), seed, randID);

    String newString = string.left(cut) + otherString.leftStrip(otherCut);
    String newOther = otherString.left(otherCut) + string.leftStrip(cut);

    if (newString.count("[") != newString.count("]"))
      continue;

    values[i] = newString;
    values[otherIndex] = newOther;
  }
  Size i;
  for (key, value in this.stringPortValues)
    this.stringPortValues[key] = values[i++];

}




