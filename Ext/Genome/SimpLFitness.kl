



/*

Story time!

  The user specifies what they care about, and the fitness function turns that into a fitness score. 

  Score em, rank em, combine ranks

  Generate scores in each criteria
  Rank scores in each criteria
  Combine ranks to generate overall score
  
  Rank overall scores


  Possible criteria:
    Leaf nodes:
      Most spread per volume
      Most spread per length of segments
      Most spread of literal leaves (not just segment ends)
    String
      Economical use of the string
      Economical use of segments
    Segment length (less or more)




  In order to score this, we need:
    SimpLFitness{};
    SimpLFitnessCriterion{};




*/



struct SimpLSpecimen {
  Lines lines;
  Xfo leaves[];
  String evolved;
};

function SimpLSpecimen(Lines lines, Xfo leaves[], String evolved) {
  this.lines = lines;
  this.leaves = leaves;
  this.evolved = evolved;
}



interface SimpLFitnessCriterionInterface {
  Scalar getImportance(); // how important is this criterion? 
  String getName(); // What is this criterion called? Will help with legibility. 
  Boolean setup(); // Do non-thread safe setup, such as calling functions on the owner of many criterion
  Scalar evaluate(SimpLSpecimen specimen); // Evaluate fitness. Will be done on all criteria. 
};

object SimpLFitnessCriterion : SimpLFitnessCriterionInterface {
  Scalar importance;
};
/// \dfgPresetDefault importance 1.0;
function SimpLFitnessCriterion(Scalar importance) {
  this.importance = importance;
}
/// \dfgPresetOmit
function Scalar SimpLFitnessCriterion.getImportance() {
  return this.importance;
}
/// \dfgPresetOmit
function String SimpLFitnessCriterion.getName() {
  return "NullCriterion";
} 
/// \dfgPresetOmit
function Boolean SimpLFitnessCriterion.setup() {
  return true;
} 
/// \dfgPresetOmit
function Scalar SimpLFitnessCriterion.evaluate(SimpLSpecimen specimen) {
  return 1.0f;
}


object SimpLFitness{
  SimpLFitnessCriterion criteria[];
  SimpLSpecimen specimens[];
  // indexed per specimen, per criteria
  Scalar specimenCritScores[][]; 
  Size specimenCritRanks[][]; 

  // indexed per specimen
  Scalar specimenRankScore[]; // the weighted average rank
};

function SimpLFitness(SimpLFitnessCriterion criteria[]) {
  this.criteria = criteria;
}

function Scalar[] SimpLFitness.apply!(SimpLSpecimen specimens[]) {
  this.specimens = specimens;

  Size numSpecimens = this.specimens.size();
  Size numCriteria = this.criteria.size();

  this.specimenCritScores.resize(numSpecimens);
  this.specimenCritRanks.resize(numSpecimens);
  this.specimenRankScore.resize(numSpecimens);
  for (Size si; si<numSpecimens; si++) {
    this.specimenCritScores[si].resize(numCriteria);
    this.specimenCritRanks[si].resize(numCriteria);
  }

  this.generateScoresInCriteria();
  this.rankScoresInCriteria();
  this.combineCriteriaRanks();
  return this.computeProbabilities();
}

private function SimpLFitness.generateScoresInCriteria!() {
  Size numSpecimens = this.specimens.size();
  Size numCriteria = this.criteria.size();

  for (Size ci; ci<numCriteria; ci++)
    this.criteria[ci].setup();

  SimpLFitness_generateScoresInCriteria_task<<<numSpecimens*numCriteria>>>(this.specimens, this.criteria, this.specimenCritScores);
  // for (Size si; si<numSpecimens; si++)
  //   for (Size ci; ci<numCriteria; ci++)
  //     this.specimenCritScores[si][ci] = this.criteria[ci].evaluate(this.specimens[si]);
}

operator SimpLFitness_generateScoresInCriteria_task<<<i>>>(SimpLSpecimen specimens[],
                                                           io SimpLFitnessCriterion criteria[],
                                                           io Scalar specimenCritScores[][]) {
  Size numSpecimens = specimens.size();
  Size numCriteria = criteria.size();
  Size ci = i / numSpecimens;
  Size si = i - ci*numSpecimens;
  specimenCritScores[si][ci] = criteria[ci].evaluate(specimens[si]);
}

private function SimpLFitness.rankScoresInCriteria!() {
  Size numSpecimens = this.specimens.size();
  Size numCriteria = this.criteria.size();

  Scalar scores[];
  Size sortedIndices[];
  scores.resize(numSpecimens);
  sortedIndices.resize(numSpecimens);
  for (Size ci; ci<numCriteria; ci++) {
    for (Size si; si<numSpecimens; si++)
      scores[si] = this.specimenCritScores[si][ci];
    Scalar sortedScores[] = stupidSortIndices(scores, sortedIndices);
    Scalar lastScore;
    Size lastRank;
    for (Size rank; rank<sortedIndices.size(); rank++) {
      Size si = sortedIndices[rank];
      if (sortedScores[rank] == lastScore) {
        // if it's a tie for first, everyone tied gets first. 
        this.specimenCritRanks[si][ci] = lastRank + 1;
      } else {
        this.specimenCritRanks[si][ci] = rank + 1;
        lastScore = sortedScores[rank];
        lastRank = rank;
      }
    }
  }
}

private function SimpLFitness.combineCriteriaRanks!() {
  Size numSpecimens = this.specimens.size();
  Size numCriteria = this.criteria.size();

  Scalar critImportance[], totalCritImportance;
  for (Size ci; ci<numCriteria; ci++) {
    Scalar importance = this.criteria[ci].getImportance();
    totalCritImportance += importance;
    critImportance.push(importance);
  }
  for (Size si; si<numSpecimens; si++) {
    Scalar totalRank;
    for (Size ci; ci<numCriteria; ci++)
      totalRank += this.specimenCritRanks[si][ci];
    this.specimenRankScore[si] = totalRank / totalCritImportance;
  }
}

private function Scalar[] SimpLFitness.computeProbabilities() {
  Size sortedIndices[];
  Scalar sortedScores[] = stupidSortIndices(this.specimenRankScore, sortedIndices);

  Scalar probabilities[];
  probabilities.resize(this.specimenRankScore.size());

  Scalar lastScore;
  Size lastRank;
  for (Size rank; rank<sortedIndices.size(); rank++) {
    Size si = sortedIndices[rank];
    if (sortedScores[rank] == lastScore) {
      // if it's a tie for first, everyone tied gets first. 
      probabilities[si] = lastRank * lastRank;
    } else {
      lastRank = rank + 1;
      lastScore = sortedScores[rank];
      probabilities[si] = lastRank * lastRank;
    }
  }
  return probabilities;
}
