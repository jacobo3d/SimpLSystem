require Geometry;

object LinesTurtle : SimpLTurtle {
  private Mat44 lastMat44;
  private Vec3 positions[];
  private Lines lines;
  private Xfo leaves[];
  private Size nbPoints;
  private Box3 bounds;
  private Boolean normalizeScale;
};


function LinesTurtle(Boolean normalizeScale) {
  this.normalizeScale = normalizeScale;
  this.lines = Lines();
}

function LinesTurtle.walk!(io SimpLInterpreter interpreter) {
  SimpLTurtle pturtle = this;
  interpreter.turtleWalker(pturtle);
}

/// \dfgPresetDefault normalizeScale true;
function Lines LinesTurtle.getResult(out Xfo leaves[]) {
  leaves = this.leaves;
  return this.lines.clone();
}
/// \internal
function LinesTurtle.setup!(Ref<SimpLInterpreter> interpreter, Size length) {
  // this.positions.resize(length);

  this.lines.clear();
  this.lines.addPoints(length);

  this.bounds = Box3();
  this.bounds.setEmpty();
}
/// \internal
function Boolean LinesTurtle.step!(Mat44 mat44, Integer branch, Integer leaf, Size index) {
  if (leaf != 0)
    this.leaves.push(Xfo(mat44));
  if (mat44 == this.lastMat44 && index != 0) // no change and not first.  
    return true;
  Vec3 pos =  mat44.multiplyVector3(Vec3());
  // this.positions[this.nbPoints] = pos;
  this.lines.setPosition(this.nbPoints, pos);
  if (branch >= 0 && this.nbPoints > 0)
    this.lines.addLine(this.nbPoints - 1, this.nbPoints);
  this.bounds.merge(pos);
  this.nbPoints++;
  this.lastMat44 = mat44;
  return true;
}
/// \internal
function LinesTurtle.finish!() {
  if (this.normalizeScale) {
    Vec3 positions[] = Vec3Attribute(this.lines.attributes.positionsAttribute).values;
    Vec3 scale(Math_max(this.bounds.min.x, this.bounds.max.x),
               Math_max(this.bounds.min.y, this.bounds.max.y),
               Math_max(this.bounds.min.z, this.bounds.max.z));
    Scalar factor = Math_max( Math_max(scale.x, scale.y), scale.z);
    Scalar divisor = Math_badDivisor(factor) ? 1.0 : 1.0 / factor;
    for (Size i; i<positions.size(); i++)
      positions[i] *= divisor;
    for (Size i; i<this.leaves.size(); i++) {
      this.leaves[i].tr *= divisor;
      this.leaves[i].sc *= divisor; 
    }
  }
  // this.positions.resize(this.nbPoints);
}